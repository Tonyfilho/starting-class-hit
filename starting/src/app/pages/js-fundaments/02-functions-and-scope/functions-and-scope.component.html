<header class="header">
  <h1>Functions & Scope: Arrow Functions, Callbacks e ComparaÃ§Ãµes.</h1>
</header>

<div class="card right-align">
  <button class="home-button" routerLink="/">Go Back to Home</button>
  <button class="home-button-pdf" (click)="downloadPDF()">ğŸ“„ Download PDF</button>
</div>

<section class="container-guide" #pdfContent>
  <div class="content-wrap">

    <h2>1. O que sÃ£o funÃ§Ãµes?</h2>
    <hr>
    <p>FunÃ§Ãµes sÃ£o blocos de cÃ³digo reutilizÃ¡veis que executam uma tarefa especÃ­fica. Podem ser declaradas de vÃ¡rias
      formas:</p>

    <pre><code>
// DeclaraÃ§Ã£o comum
function saudacao(nome: string) {{"{"}}
  return `OlÃ¡, ${{"{"}}nome{{"}"}}`;
{{"}"}}

// ExpressÃ£o de funÃ§Ã£o
const saudacao2 = function(nome: string) {{"{"}}
  return `OlÃ¡, ${{"{"}}nome{{"}"}}`;
{{"}"}}

// Arrow function
const saudacao3 = (nome: string) => `OlÃ¡, ${{"{"}}nome{{"}"}}`;
    </code></pre>

    <h2>2. Arrow Functions</h2>
    <hr>
    <p>Introduzidas no ES6, possuem uma sintaxe mais curta e nÃ£o possuem seu prÃ³prio <code>this</code>.</p>

    <pre><code>
const somar = (a: number, b: number): number => a + b;
console.log(somar(2, 3)); // 5
    </code></pre>

    <p>Arrow functions sÃ£o ideais para callbacks e funÃ§Ãµes curtas.</p>

    <h2>3. Callbacks</h2>
    <hr>
    <p>FunÃ§Ãµes que sÃ£o passadas como argumento para outras funÃ§Ãµes e executadas posteriormente.</p>

    <pre><code>
function processar(valor: number, callback: (n: number) => void) {{"{"}}
  console.log('Processando...');
  callback(valor);
{{"}"}}

processar(10, (n) => console.log(`Valor processado: ${{"{"}}n{{"}"}}`));
    </code></pre>

    <h2>4. Escopo e <code>this</code></h2>
    <hr>
    <p>Arrow functions nÃ£o criam seu prÃ³prio escopo de <code>this</code>. Isso Ã© Ãºtil em mÃ©todos de classe:</p>

    <pre><code>
class Pessoa {{"{"}}
  nome = 'JoÃ£o';

  mostrarNomeTradicional() {{"{"}}
    setTimeout(function () {{"{"}}
      console.log('Tradicional:', this.nome); // undefined
    {{"}"}}, 1000);
  {{"}"}}

  mostrarNomeArrow() {{"{"}}
    setTimeout(() => {{"{"}}
      console.log('Arrow:', this.nome); // JoÃ£o
    {{"}"}}, 1000);
  {{"}"}}
{{"}"}}
    </code></pre>

    <h2>ExplicaÃ§Ã£o: Por que Arrow Functions nÃ£o tÃªm <code>this</code> prÃ³prio?</h2>
    <hr>
    <p>
      Em JavaScript, o valor de <code>this</code> Ã© determinado pelo **contexto de chamada da funÃ§Ã£o**.
      Em funÃ§Ãµes tradicionais, <code>this</code> muda dependendo de como a funÃ§Ã£o Ã© chamada.
      JÃ¡ as <strong>arrow functions</strong>, introduzidas no ES6, <b>nÃ£o criam um novo escopo de <code>this</code></b>.
      Em vez disso, elas capturam o valor de <code>this</code> do <b>contexto em que foram definidas</b> â€” o chamado
      "lexical this".
    </p>

    <p>
      Isso Ã© especialmente Ãºtil em mÃ©todos de classe, onde muitas vezes usamos funÃ§Ãµes assÃ­ncronas como
      <code>setTimeout</code> ou <code>map</code>.
      Nessas situaÃ§Ãµes, funÃ§Ãµes tradicionais perdem a referÃªncia ao objeto original (a instÃ¢ncia da classe), resultando
      em um <code>this</code> <b>undefined</b> ou incorreto.
    </p>

    <p>
      Usar uma arrow function dentro desses mÃ©todos garante que o <code>this</code> continue se referindo corretamente Ã 
      instÃ¢ncia da classe.
    </p>
    <h2>Diagrama Visual: Escopo de <code>this</code></h2>
    <hr>
    <p>O diagrama abaixo ilustra como o <code>this</code> se comporta em funÃ§Ãµes tradicionais e em arrow functions
      dentro de uma classe:</p>

    <pre><code>
Classe Pessoa:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Pessoa                      â”‚
â”‚ â”œâ”€ nome = 'JoÃ£o'            â”‚
â”‚ â”œâ”€ mostrarNomeTradicional() â”‚
â”‚ â”‚   â””â”€ setTimeout(function(){{"{"}}
â”‚ â”‚         this.nome â†’ âŒ undefined (escopo global)
â”‚ â”œâ”€ mostrarNomeArrow()       â”‚
â”‚     â””â”€ setTimeout(() => {{"{"}}
â”‚         this.nome â†’ âœ… 'JoÃ£o' (herda da classe Pessoa)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>





    <h2>5. Comparativo: FunÃ§Ã£o Comum vs Arrow</h2>
    <hr>
    <div style="overflow-x: auto;">
      <table class="comparison-table">
        <thead>
          <tr>
            <th>CaracterÃ­stica</th>
            <th>FunÃ§Ã£o Comum</th>
            <th>Arrow Function</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Sintaxe</td>
            <td><code>function nome() {{"{"}}{{"}"}}</code></td>
            <td><code>const nome = () => {{"{"}}{{"}"}}</code></td>
          </tr>
          <tr>
            <td>Possui <code>this</code> prÃ³prio</td>
            <td>âœ… Sim</td>
            <td>âŒ NÃ£o</td>
          </tr>
          <tr>
            <td>Uso em classes</td>
            <td>Requer bind ou referÃªncia</td>
            <td>Herda o <code>this</code> externo</td>
          </tr>
          <tr>
            <td>Legibilidade</td>
            <td>Mais verbosa</td>
            <td>Mais concisa</td>
          </tr>
          <tr>
            <td>Ideal para</td>
            <td>MÃ©todos complexos</td>
            <td>Callbacks, funÃ§Ãµes pequenas</td>
          </tr>
        </tbody>
      </table>
    </div>

    <h2>Resumo TÃ©cnico</h2>
    <hr>
    <ul>
      <li>âœ… FunÃ§Ãµes podem ser declaradas de vÃ¡rias formas.</li>
      <li>âœ… Callbacks sÃ£o funÃ§Ãµes passadas como argumento.</li>
      <li>âœ… Escolha o tipo ideal de funÃ§Ã£o para cada situaÃ§Ã£o.</li>
      <li>âœ… FunÃ§Ãµes tradicionais possuem seu prÃ³prio <code>this</code> â€” o valor depende de como a funÃ§Ã£o Ã© chamada.
      </li>
      <li>âœ… Arrow functions nÃ£o tÃªm seu prÃ³prio <code>this</code>.</li>
      <li>âœ… Arrow functions **herdam** o <code>this</code> do contexto onde foram definidas.</li>
      <li>âœ… Prefira arrow functions para preservar o escopo externo do <code>this</code>.</li>
      <li>âœ… Em mÃ©todos de classe, arrow functions evitam problemas comuns com <code>this</code> em callbacks assÃ­ncronos
        como <code>setTimeout</code>.</li>
    </ul>

  </div>
</section>
